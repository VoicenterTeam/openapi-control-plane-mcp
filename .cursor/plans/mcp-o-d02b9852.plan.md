<!-- d02b9852-66c3-4d3f-b07d-2f62219a5637 b3223ff6-12b5-4acc-b48e-e184f0b5fed1 -->
# OpenAPI Control Plane MCP Server - Detailed Implementation Plan

## Overview

Building MCP server for OpenAPI management with TypeScript, Fastify, comprehensive Jest testing, incremental tool development (one tool = one part), and complete documentation. Each tool is fully tested before moving to next. 20+ parts for proper granularity.

**Architecture:** File-based storage, BaseTool inheritance, camelCase vars, PascalCase classes, Uncle Bob clean code, humorous JSDoc

---

## Part 1: Project Foundation & Tooling Setup

1. Initialize Node.js project: `npm init`, add TypeScript, Fastify, @modelcontextprotocol/sdk, @apidevtools/swagger-parser, unflatify
2. Add dev dependencies: Jest, ts-jest, @types/jest, @types/node, eslint, prettier, eslint-config-airbnb-base, eslint-plugin-import, eslint-config-prettier
3. Create `tsconfig.json`: strict mode, ES2022, ESM output, paths for @/ imports, sourceMap for debugging
4. Create `jest.config.js`: TypeScript preset, coverage thresholds 80%, testMatch patterns, setupFilesAfterEnv
5. Configure ESLint `.eslintrc.json`: extend ["airbnb-base", "plugin:@typescript-eslint/recommended", "prettier"], TypeScript parser, rules for unused vars, no-console in production
6. Create `.prettierrc`: singleQuote: true, semi: false, trailingComma: 'es5', printWidth: 100, tabWidth: 2, arrowParens: 'avoid'
7. Add `.eslintignore`: node_modules/, dist/, coverage/, *.test.ts
8. Add `.cursorignore`: node_modules/, dist/, coverage/, data/, .env, *.log per org security standards
9. Create folder structure: src/{tools,services,storage,types,utils}, tests/{unit,integration,helpers,fixtures}, docs/ with thematic subfolders (foundation-tooling, types-interfaces, utilities-logging, storage-abstraction, etc.)
10. Add npm scripts: dev (tsx watch), build (tsc), test, test:watch, test:coverage, test:debug (--inspect-brk), lint (eslint src/), lint:fix (eslint --fix), format (prettier --write), format:check
11. Create `.env.example`: PORT=3000, HOST=0.0.0.0, DATA_DIR=./data, LOG_LEVEL=info, NODE_ENV=development, CUSTOM_X_ATTRIBUTES=x-logo,x-category,x-team,x-internal
12. Create `.gitignore`: node_modules/, dist/, coverage/, data/, .env, *.log, .DS_Store, .cursor/
13. Initialize Git repo: `git init`, initial commit with scaffolding
14. Create sample fixtures: `tests/fixtures/petstore-v3.0.yaml`, `petstore-v3.1.yaml`, `swagger-v2.0.yaml` with x-logo examples
15. Verify build: `npm run build`, check dist/ output, verify ESLint: `npm run lint`, verify Prettier: `npm run format:check`
16. **Create `docs/part-01-foundation/README.md`**: Document project setup, tooling choices, folder structure
17. **Create `AGENTS.md`**: Initial version with reference to `docs/part-01-foundation/` for setup instructions

---

## Part 2: TypeScript Types & Interfaces + Custom x- Attributes Config

1. Create `src/types/openapi.ts`: Import OpenAPIV3, OpenAPIV3_1 from openapi-types package
2. Add discriminated union: `type OpenAPIDocument = { version: '3.0', spec: OpenAPIV3.Document } | ...`
3. Add branded types: `type ApiId = string & { __brand: 'ApiId' }`, `type VersionTag = string & { __brand: 'VersionTag' }`
4. Create `src/types/metadata.ts`: Define VersionMetadata interface (version, created_at, created_by, parent_version, description, changes, validation, stats)
5. Define ApiMetadata interface (api_id, name, created_at, current_version, versions array, owner)
6. Define AuditEvent interface (timestamp, event, api_id, version, user, details, **llm_reason?: string**)
7. Define ChangesSummary interface (endpoints_added, endpoints_modified, endpoints_deleted, schemas_added, breaking_changes)
8. Create `src/types/mcp-tool.ts`: Define ToolResult interface (content, isError)
9. Define ToolDescription interface (name, description, inputSchema)
10. Define abstract BaseTool class: abstract execute(), abstract describe(), validate() with Zod, **add llmReason?: string to all tool params**
11. Create `src/types/errors.ts`: Define error type enums (VALIDATION_ERROR, STORAGE_ERROR, TOOL_ERROR)
12. Add custom error interfaces extending Error with additional fields
13. Create type guards: `isOpenAPI30()`, `isOpenAPI31()`, `isSwagger20()`
14. **Create `src/types/custom-extensions.ts`**: Define XAttribute interface (name, description, applicableTo: ['info', 'operation', 'schema', 'parameter', etc.])
15. Define CustomExtensionsConfig interface for environment-based x- attribute configuration
16. Add JSDoc to all types explaining their purpose with humor
17. Update `.env.example`: Add CUSTOM_X_ATTRIBUTES='x-logo,x-category,x-internal,x-team' (comma-separated list)
18. Test compilation: `npm run build`, verify no TypeScript errors
19. **Create `docs/part-02-types/`**: Document type system, custom extensions, LLM reasoning
20. **Update `AGENTS.md`**: Add reference to `docs/part-02-types/` for type definitions and custom extensions

---

## Part 3: Core Utilities - Logger & Error Handling

1. Install pino and pino-pretty: `npm install pino pino-pretty`
2. Create `src/utils/logger.ts`: Import pino, export configured logger instance
3. Configure logger: level from env, redact password/token/apiKey fields, pretty print in dev
4. Add custom log methods: `logToolCall()`, `logStorageOperation()`, `logValidation()`
5. Add humorous log messages helper: `addJoke(message: string)` appending random dev jokes
6. **Jest tests** `tests/unit/utils/logger.test.ts`:

- Test logger initialization with different LOG_LEVELs
- Test redaction: log object with password field, verify not in output
- Test log levels: debug, info, warn, error
- Test pretty print in development vs JSON in production
- Mock pino to verify correct configuration

7. Create `src/utils/errors.ts`: Define ValidationError class extending Error
8. Define StorageError, ToolError, ReferenceError classes
9. Add error factory functions: `createValidationError()`, `createStorageError()`
10. Add error serialization: `serializeError()` for logging and MCP responses
11. **Jest tests** `tests/unit/utils/errors.test.ts`:

- Test error class instantiation with message and cause
- Test error serialization to JSON
- Test error factory functions
- Test error instanceof checks
- Test error stack traces preserved

12. Create `src/utils/validation.ts`: Helper functions for common validations
13. Add `validateApiId()`, `validateVersionTag()`, `validatePath()` with regex patterns
14. **Jest tests** `tests/unit/utils/validation.test.ts`: Test all validation functions with valid/invalid inputs

---

## Part 4: Storage Abstraction Layer & FileSystem Implementation

1. Create `src/storage/base-storage-provider.ts`: Abstract class for storage operations
2. Define abstract methods: `read(key: string)`, `write(key: string, data: string)`, `exists(key: string)`, `delete(key: string)`, `list(prefix: string)`, `ensureDirectory(path: string)`
3. Add JSDoc: "The storage abstraction - making it easy to swap file system for S3, Redis, or carrier pigeons"
4. Define StorageConfig interface for provider configuration
5. Create `src/storage/file-system-storage.ts`: Concrete FileSystem implementation extending BaseStorageProvider
6. Implement constructor accepting baseDir from config
7. Implement `read(key: string)`: Use fs/promises to read file at baseDir/key
8. Implement `write(key: string, data: string)`: Atomic write with temp file + rename pattern
9. Implement `exists(key: string)`: Check file existence with fs.access
10. Implement `delete(key: string)`: Remove file with safety checks
11. Implement `list(prefix: string)`: List directory contents recursively
12. Implement `ensureDirectory(path: string)`: Create directory tree with fs.mkdir recursive
13. Add JSDoc: "The file system whisperer - talking to your disk with the gentleness of a Zen master"
14. **Jest tests** `tests/unit/storage/base-storage-provider.test.ts`:

- Test abstract class cannot be instantiated
- Test all abstract methods are defined

15. **Jest tests** `tests/unit/storage/file-system-storage.test.ts`:

- Mock fs/promises module
- Test read() calls fs.readFile with correct path
- Test read() throws StorageError on file not found
- Test write() performs atomic operation (temp + rename)
- Test write() cleans up temp file on error
- Test exists() returns true/false correctly
- Test delete() removes file
- Test delete() throws on non-existent file
- Test list() returns array of keys
- Test list() filters by prefix
- Test ensureDirectory() creates nested directories
- Test concurrent write() calls don't corrupt

16. Install proper-lockfile: `npm install proper-lockfile`
17. Create `src/storage/lock-manager.ts`: File locking wrapper using proper-lockfile
18. Implement `withLock(key: string, operation: Function)` acquiring lock, executing, releasing in finally
19. **Jest tests** `tests/unit/storage/lock-manager.test.ts`:

- Mock proper-lockfile
- Test lock acquired before operation
- Test lock released after successful operation
- Test lock released even after operation error (finally block)
- Test lock retry mechanism on contention
- Test lock timeout throws error

20. **Create `docs/part-04-storage/README.md`**: Document storage abstraction pattern, how to implement S3StorageProvider
21. **Update `AGENTS.md`**: Reference `docs/part-04-storage/` for storage architecture

---

## Part 5: Metadata Storage & Version Management Services

1. Create `src/storage/metadata-store.ts`: Service for reading/writing metadata.json files
2. Implement `readApiMetadata(apiId: string): Promise<ApiMetadata>` reading api metadata.json
3. Implement `writeApiMetadata(apiId: string, metadata: ApiMetadata)` with validation
4. Implement `readVersionMetadata(apiId: string, version: string): Promise<VersionMetadata>`
5. Implement `writeVersionMetadata()` for version-specific metadata
6. Add JSON schema validation using Zod before writing
7. **Jest tests** `tests/unit/storage/metadata-store.test.ts`:

- Mock file-storage module
- Test readApiMetadata parses JSON correctly
- Test readApiMetadata throws on invalid JSON
- Test readApiMetadata throws on missing file
- Test writeApiMetadata validates schema with Zod
- Test writeApiMetadata rejects invalid metadata
- Test version metadata operations
- Test handles concurrent reads/writes

8. Create `src/services/audit-logger.ts`: JSON Lines audit trail
9. Implement `logEvent(event: AuditEvent)` appending to audit.jsonl
10. Implement `queryAuditLog(filters: AuditFilters): Promise<AuditEvent[]>` reading and filtering
11. Add stream reading for large audit files
12. **Jest tests** `tests/unit/services/audit-logger.test.ts`:

- Mock file-storage
- Test logEvent appends JSON line with newline
- Test multiple events create multiple lines
- Test queryAuditLog filters by api_id
- Test queryAuditLog filters by date range
- Test queryAuditLog filters by event type
- Test handles corrupted JSON lines gracefully

---

## Part 6: Spec Manager Service - Core OpenAPI Operations

1. Create `src/services/spec-manager.ts`: Core OpenAPI spec operations
2. Implement `loadSpec(apiId: string): Promise<OpenAPIDocument>` loading current.yaml
3. Add support for YAML and JSON formats using js-yaml
4. Implement `saveSpec(apiId: string, spec: object)` with atomic write and backup
5. Implement `parseSpec(content: string)` using @apidevtools/swagger-parser
6. Implement `validateSpec(spec: object)` basic validation with SwaggerParser.validate()
7. Implement `listApis(): Promise<ApiId[]>` scanning data/specs/ directory
8. Implement `getApiInfo(apiId: string): Promise<ApiMetadata>` using metadata-store
9. Implement `createApi(apiId: string, initialSpec: object, metadata: ApiMetadata)` initializing new API
10. Add helper `detectOpenAPIVersion(spec: object): '2.0' | '3.0' | '3.1'`
11. Add JSDoc explaining this is "The API librarian - cataloging and organizing your OpenAPI specs with obsessive precision"
12. **Jest tests** `tests/unit/services/spec-manager.test.ts`:

- Mock file-storage, metadata-store, swagger-parser
- Test loadSpec reads file and parses YAML
- Test loadSpec handles JSON format
- Test loadSpec throws on invalid spec
- Test saveSpec writes atomically
- Test saveSpec creates backup of previous version
- Test parseSpec handles Swagger 2.0, OpenAPI 3.0, 3.1
- Test validateSpec detects invalid specs
- Test listApis returns array of API IDs
- Test createApi initializes folder structure
- Test createApi writes metadata
- Test detectOpenAPIVersion correctly identifies versions
- Test concurrent loadSpec calls don't interfere

---

## Part 7: BaseTool Implementation & Server Setup

1. Create `src/tools/base-tool.ts`: Implement abstract BaseTool class
2. Add abstract `execute(params: any): Promise<ToolResult>` method
3. Add abstract `describe(): ToolDescription` method
4. Implement concrete `validate(params: any, schema: z.ZodSchema)` using Zod
5. Add helper `success(message: string, data?: any): ToolResult` creating success response
6. Add helper `error(message: string, details?: any): ToolResult` creating error response
7. Add logging integration: log tool calls with params and results
8. Add audit logging integration: call auditLogger on tool execution
9. Add JSDoc: "The tool factory - every tool inherits from this, like kids inheriting dad jokes"
10. **Jest tests** `tests/unit/tools/base-tool.test.ts`:

- Create concrete test tool extending BaseTool
- Test validate() with valid params passes
- Test validate() with invalid params throws ValidationError
- Test success() creates correct ToolResult structure
- Test error() creates correct ToolResult with isError=true
- Test execute() logs tool calls
- Test execute() logs audit events

11. Create `src/server.ts`: Initialize Fastify and MCP server
12. Add Fastify initialization with logger, trustProxy
13. Add MCP server initialization with capabilities
14. Add health check endpoint: GET /health returning { status: 'ok', version }
15. Export buildServer() function for testing

---

## Part 8: Tool #1 - spec_read (Read Operations)

1. Create `src/tools/spec-read-tool.ts` extending BaseTool
2. Define Zod schema for params: query_type enum, optional path, method, schema_name, filters
3. Implement `execute()` method with switch on query_type
4. Implement `handleFullSpec()` returning entire spec using spec-manager
5. Implement `handleEndpointsList()` extracting all paths from spec
6. Implement `handleEndpointDetail()` returning specific path+method operation
7. Implement `handleSchemaDetail()` returning specific schema from components
8. Implement `handleInfo()` returning info object
9. Implement `handleServers()` returning servers array
10. Add filter support: filter by tags, deprecated status
11. Add JSDoc: "The API explorer - like Google Maps but for your OpenAPI spec, minus the traffic updates"
12. Implement `describe()` returning tool description for MCP registration
13. **Jest tests** `tests/unit/tools/spec-read-tool.test.ts`:

- Mock spec-manager service
- Test full_spec query returns complete spec
- Test endpoints_list returns array of paths
- Test endpoint_detail with valid path/method
- Test endpoint_detail with invalid path throws error
- Test schema_detail with valid schema name
- Test schema_detail with non-existent schema throws error
- Test info query returns info object
- Test servers query returns servers array
- Test filter by tags works correctly
- Test filter by deprecated status
- Test validate() rejects invalid query_type
- Test validate() requires path for endpoint_detail
- Test validate() requires schema_name for schema_detail

14. Register SpecReadTool in `src/server.ts` with MCP server
15. Manual test: Start server, use MCP inspector to call spec_read tool

---

## Part 9: Tool #2 - spec_validate (Validation Operations)

1. Install @stoplight/spectral-core and @stoplight/spectral-rulesets
2. Create `src/services/validator.ts`: Spectral integration service
3. Initialize Spectral with OAS ruleset
4. Implement `validateWithSpectral(spec: object, ruleset: string): Promise<SpectralResults>`
5. Implement `categorizeResults(results: ISpectralDiagnostic[])` grouping by severity
6. Implement `formatValidationReport(categorized: object)` creating human-readable output
7. **Jest tests** `tests/unit/services/validator.test.ts`:

- Mock @stoplight/spectral-core
- Test validateWithSpectral calls spectral.run()
- Test categorizeResults groups errors, warnings, info, hints
- Test formatValidationReport creates readable output
- Test handles specs with no issues
- Test handles specs with multiple issues
- Test custom ruleset loading

8. Create `src/tools/spec-validate-tool.ts` extending BaseTool
9. Define Zod schema: validation_type, lint_rules, compare_against, severity_threshold
10. Implement `execute()` coordinating validation operations
11. Implement validation_type='full': SwaggerParser + Spectral
12. Implement validation_type='schema_only': Only SwaggerParser
13. Implement validation_type='references_only': Check all $refs resolve
14. Add JSDoc: "The spec bouncer - checking IDs at the door, making sure your API isn't trying to sneak in with a fake schema"
15. **Jest tests** `tests/unit/tools/spec-validate-tool.test.ts`:

- Mock validator service
- Test full validation calls both SwaggerParser and Spectral
- Test schema_only skips Spectral
- Test references_only validates $refs
- Test severity_threshold filters results
- Test validate() rejects invalid validation_type
- Test returns appropriate error for invalid specs
- Test returns success for valid specs
- Test custom ruleset application
- Test compare_against parameter (prepare for later breaking change feature)

---

## Part 10: Version Management Service & Infrastructure

1. Create `src/services/version-manager.ts`: Version control operations
2. Implement `createVersion(apiId: string, versionName: string, description: string, user: string)`
3. Add version name validation: check semver format (v1.2.3) or timestamp (v20250109-120000)
4. Copy current.yaml to versions/{version}/spec.yaml
5. Generate version metadata with stats (endpoint count, schema count, file size)
6. Write metadata to versions/{version}/metadata.json
7. Update API metadata with new version in versions array
8. Log audit event for version creation
9. Implement `listVersions(apiId: string): Promise<VersionTag[]>`
10. Implement `getVersion(apiId: string, version: string): Promise<{spec, metadata}>`
11. Implement `deleteVersion(apiId: string, version: string)` with safety checks
12. Implement `rollbackToVersion(apiId: string, version: string)` copying version to current.yaml
13. Add JSDoc: "The time lord - managing the space-time continuum of your API specs"
14. **Jest tests** `tests/unit/services/version-manager.test.ts`:

- Mock file-storage, metadata-store, spec-manager
- Test createVersion copies spec file
- Test createVersion generates metadata
- Test createVersion validates version name format
- Test createVersion rejects duplicate version names
- Test createVersion logs audit event
- Test listVersions returns sorted array
- Test getVersion loads spec and metadata
- Test getVersion throws on non-existent version
- Test deleteVersion removes files
- Test deleteVersion prevents deleting current version
- Test rollbackToVersion copies files correctly
- Test rollbackToVersion updates current version metadata

15. Create `src/utils/diff-calculator.ts`: Calculate changes between specs
16. Implement `calculateDiff(oldSpec: object, newSpec: object): ChangesSummary`
17. Detect endpoints added, modified, deleted by comparing paths
18. Detect schemas added, modified, deleted in components
19. **Jest tests** `tests/unit/utils/diff-calculator.test.ts`:

- Test detects added endpoints
- Test detects deleted endpoints
- Test detects modified endpoints (operation changes)
- Test detects added schemas
- Test detects deleted schemas
- Test detects no changes on identical specs
- Test handles edge cases (empty paths, no components)

---

## Part 11: Tool #3 - metadata_update (First Write Tool)

1. Create `src/tools/metadata-update-tool.ts` extending BaseTool
2. Define Zod schema: section enum (info, servers, tags, externalDocs), data object, merge boolean
3. Implement `execute()` loading spec, updating section, validating, saving
4. Implement `updateInfo(spec: object, data: Partial<InfoObject>, merge: boolean)` updating title, description, version, contact, license
5. Implement `updateServers(spec: object, servers: ServerObject[])` replacing servers array
6. Implement `updateTags(spec: object, tagOperations: object)` handling add/update/delete tag operations
7. Implement `updateExternalDocs(spec: object, docs: ExternalDocsObject)` updating external documentation
8. Add validation after update to ensure spec still valid
9. Add audit logging for each metadata change
10. Add JSDoc: "The API resume editor - polishing your spec's bio so it looks good on LinkedIn"
11. **Jest tests** `tests/unit/tools/metadata-update-tool.test.ts`:

- Mock spec-manager, audit-logger
- Test updateInfo merges fields correctly
- Test updateInfo replaces all fields when merge=false
- Test updateInfo validates required fields (title, version)
- Test updateServers replaces array
- Test updateServers validates server objects
- Test updateTags adds new tag
- Test updateTags updates existing tag
- Test updateTags deletes tag
- Test updateExternalDocs updates correctly
- Test validate() rejects invalid section
- Test validate() requires data object
- Test execute() calls spec-manager.saveSpec()
- Test execute() logs audit event
- Test execute() rejects changes that break validation

12. Register MetadataUpdateTool in server.ts
13. **Integration test** `tests/integration/metadata-update-tool.test.ts`:

- Start test server with fixture data
- Call metadata_update via MCP to update info.title
- Verify change persisted by calling spec_read
- Verify audit log entry created
- Test rollback: update, verify, rollback, verify restored

---

## Part 12: Tool #4 - schema_manage (Schema Operations)

1. Create `src/tools/schema-manage-tool.ts` extending BaseTool
2. Define Zod schema: action enum (add, update, delete, add_property, remove_property), schema_name, schema_definition, property_path, property_definition
3. Implement `execute()` with switch on action
4. Implement `addSchema(spec: object, name: string, definition: SchemaObject)`
5. Add check: schema doesn't already exist
6. Add schema to components.schemas
7. Implement `updateSchema(spec: object, name: string, definition: SchemaObject)`
8. Add check: schema exists
9. Replace schema definition
10. Implement `deleteSchema(spec: object, name: string)`
11. Add safety check: find all $refs to this schema, error if used
12. Implement `findSchemaReferences(spec: object, schemaName: string): string[]`
13. Recursively search spec for `$ref: #/components/schemas/{schemaName}`
14. Implement `addProperty(spec: object, schemaName: string, propertyPath: string, definition: object)`
15. Support nested paths like "address.city" using path parsing
16. Implement `removeProperty(spec: object, schemaName: string, propertyPath: string)`
17. Add JSDoc: "The schema architect - designing data blueprints with the precision of a Swiss watchmaker"
18. **Jest tests** `tests/unit/tools/schema-manage-tool.test.ts`:

- Mock spec-manager
- Test addSchema adds to components.schemas
- Test addSchema rejects duplicate names
- Test updateSchema modifies existing schema
- Test updateSchema throws on non-existent schema
- Test deleteSchema removes schema
- Test deleteSchema rejects if schema is referenced
- Test findSchemaReferences finds all $refs
- Test findSchemaReferences handles nested $refs
- Test addProperty adds to properties object
- Test addProperty handles nested paths (address.city)
- Test removeProperty removes from properties
- Test removeProperty handles nested paths
- Test validate() requires schema_name
- Test validate() requires schema_definition for add/update
- Test execute() logs audit events

19. Register SchemaManageTool in server.ts
20. **Integration test** `tests/integration/schema-manage-tool.test.ts`:

- Create schema, verify with spec_read
- Add property, verify structure
- Delete schema, verify removal
- Test reference safety: create schema, reference it, attempt delete, verify error

---

## Part 13: Tool #5 - endpoint_manage (Endpoint CRUD)

1. Create `src/tools/endpoint-manage-tool.ts` extending BaseTool
2. Define Zod schema: action (add, update, delete), path, method, operation (summary, description, operationId, tags, deprecated, etc.)
3. Implement `execute()` with action switch
4. Implement `addEndpoint(spec: object, path: string, method: string, operation: OperationObject)`
5. Initialize spec.paths if undefined
6. Initialize spec.paths[path] if undefined
7. Add operation to spec.paths[path][method.toLowerCase()]
8. Validate path format (must start with /)
9. Implement `updateEndpoint(spec: object, path: string, method: string, updates: Partial<OperationObject>)`
10. Merge updates into existing operation
11. Implement `deleteEndpoint(spec: object, path: string, method: string)`
12. Remove operation from path
13. If path has no remaining methods, remove entire path entry
14. Add JSDoc: "The API traffic controller - routing HTTP requests like a boss since this very moment"
15. **Jest tests** `tests/unit/tools/endpoint-manage-tool.test.ts`:

- Test addEndpoint creates path and operation
- Test addEndpoint on existing path adds new method
- Test addEndpoint rejects duplicate path+method
- Test addEndpoint validates path format (must start with /)
- Test addEndpoint validates method enum
- Test updateEndpoint merges operation fields
- Test updateEndpoint preserves existing fields not in updates
- Test updateEndpoint throws on non-existent endpoint
- Test deleteEndpoint removes operation
- Test deleteEndpoint removes path if last method
- Test deleteEndpoint preserves path if other methods exist
- Test validate() requires path and method
- Test validate() requires operation for add action
- Test execute() logs audit events with endpoint details

16. Register EndpointManageTool in server.ts
17. **Integration test** `tests/integration/endpoint-manage-tool.test.ts`:

- Add endpoint, verify with spec_read endpoint_detail
- Update endpoint, verify changes
- Delete endpoint, verify removal
- Test adding multiple methods to same path

---

## Part 14: Tool #6 - parameters_configure (Parameter Management)

1. Create `src/tools/parameters-configure-tool.ts` extending BaseTool
2. Define Zod schema: path, method, parameter_location (query, path, header, cookie, body), parameters array, replace boolean
3. Implement `execute()` loading endpoint, updating parameters
4. Implement `setQueryParameters(operation: OperationObject, params: ParameterObject[], replace: boolean)`
5. Merge or replace operation.parameters
6. Implement `setPathParameters(operation: OperationObject, params: ParameterObject[], replace: boolean)`
7. Validate all path params in URL are defined
8. Validate no duplicate parameter names in same location
9. Implement `setHeaderParameters(operation: OperationObject, params: ParameterObject[], replace: boolean)`
10. Implement `setCookieParameters(operation: OperationObject, params: ParameterObject[], replace: boolean)`
11. Implement `setBodyParameter(operation: OperationObject, requestBody: RequestBodyObject)`
12. Set operation.requestBody with content types and schema
13. Add helper `validateParameterUniqueness(params: ParameterObject[]): boolean`
14. Add helper `extractPathParams(path: string): string[]` getting {id}, {userId} from path
15. Add JSDoc: "The parameter plumber - connecting the data pipes from user input to your API logic"
16. **Jest tests** `tests/unit/tools/parameters-configure-tool.test.ts`:

- Test setQueryParameters adds to operation.parameters
- Test setQueryParameters with replace=true replaces all query params
- Test setQueryParameters with replace=false merges params
- Test setPathParameters validates all path params defined
- Test setPathParameters rejects if path param missing
- Test validateParameterUniqueness detects duplicates
- Test validateParameterUniqueness allows same name in different locations
- Test extractPathParams correctly parses {id}, {userId} from path
- Test setBodyParameter sets operation.requestBody
- Test setBodyParameter supports multiple content types
- Test validate() requires path and method
- Test validate() requires parameters or requestBody
- Test execute() updates endpoint and saves

17. Register ParametersConfigureTool in server.ts
18. **Integration test** `tests/integration/parameters-configure-tool.test.ts`:

- Create endpoint with parameters_configure
- Verify parameters with spec_read
- Test merge vs replace behavior
- Test path parameter validation

---

## Part 15: Tool #7 - responses_configure (Response Management)

1. Create `src/tools/responses-configure-tool.ts` extending BaseTool
2. Define Zod schema: path, method, status_code, response (description, content, headers, examples), action (set, delete)
3. Implement `execute()` loading endpoint, updating responses
4. Implement `setResponse(operation: OperationObject, statusCode: string, response: ResponseObject)`
5. Initialize operation.responses if undefined
6. Set operation.responses[statusCode] = response
7. Implement `deleteResponse(operation: OperationObject, statusCode: string)`
8. Remove response from operation.responses
9. Implement `validateResponseStructure(response: ResponseObject): boolean`
10. Check description exists (required)
11. Validate content media types if present
12. Implement `setResponseExample(response: ResponseObject, mediaType: string, exampleName: string, example: any)`
13. Add examples to content[mediaType].examples
14. Add JSDoc: "The response choreographer - teaching your API how to answer questions with style and grace"
15. **Jest tests** `tests/unit/tools/responses-configure-tool.test.ts`:

- Test setResponse creates response object
- Test setResponse validates description required
- Test setResponse handles multiple media types
- Test setResponse handles response headers
- Test deleteResponse removes response
- Test deleteResponse doesn't error if response doesn't exist
- Test setResponseExample adds example
- Test setResponseExample handles multiple examples
- Test validateResponseStructure rejects missing description
- Test validateResponseStructure accepts valid response
- Test validate() requires status_code
- Test validate() requires response for set action
- Test execute() updates and saves spec

16. Register ResponsesConfigureTool in server.ts
17. **Integration test** `tests/integration/responses-configure-tool.test.ts`:

- Create endpoint with response
- Add multiple status codes (200, 404, 500)
- Add examples to responses
- Verify with spec_read
- Test delete response

---

## Part 16: Tool #8 - references_manage ($ref Operations)

1. Install @apidevtools/json-schema-ref-parser
2. Create `src/tools/references-manage-tool.ts` extending BaseTool
3. Define Zod schema: action (add_ref, update_ref, resolve_ref, find_refs, validate_refs), location, ref_path, target_schema
4. Implement `addReference(spec: object, location: RefLocation, targetSchema: string)`
5. Convert inline schema to $ref: `{ $ref: '#/components/schemas/TargetSchema' }`
6. Store original schema in components.schemas if not exists
7. Implement `resolveReference(spec: object, refPath: string): object`
8. Use $RefParser.dereference() to resolve $ref
9. Return resolved schema object
10. Implement `findReferences(spec: object, targetSchema: string): RefLocation[]`
11. Recursively traverse spec looking for `$ref` properties
12. Return array of locations where schema is referenced
13. Implement `validateReferences(spec: object): ValidationResult`
14. Check all $refs point to existing components
15. Detect circular references
16. Report broken references
17. Add JSDoc: "The reference librarian - keeping your schemas organized like the Library of Congress"
18. **Jest tests** `tests/unit/tools/references-manage-tool.test.ts`:

- Test addReference converts inline schema to $ref
- Test addReference preserves original schema in components
- Test resolveReference returns dereferenced schema
- Test resolveReference handles nested $refs
- Test findReferences finds all occurrences
- Test findReferences handles $refs in parameters, responses, schemas
- Test validateReferences detects broken $refs
- Test validateReferences detects circular references
- Test validateReferences passes on valid refs
- Test validate() requires action
- Test validate() requires location for add_ref

19. Register ReferencesManageTool in server.ts
20. **Integration test** `tests/integration/references-manage-tool.test.ts`:

- Create schema, add reference to it, verify $ref created
- Find all references to schema
- Validate references
- Test circular reference detection

---

## Part 17: Tool #9 - security_configure (Security Management)

1. Create `src/tools/security-configure-tool.ts` extending BaseTool
2. Define Zod schema: action (add_scheme, update_scheme, delete_scheme, apply_to_endpoint, apply_global), scheme_name, scheme_definition, endpoint, scopes
3. Implement `addSecurityScheme(spec: object, name: string, definition: SecuritySchemeObject)`
4. Initialize spec.components.securitySchemes if needed
5. Add scheme to components.securitySchemes[name]
6. Validate scheme type (apiKey, http, oauth2, openIdConnect)
7. Implement `validateSecurityScheme(scheme: SecuritySchemeObject): boolean`
8. Validate apiKey: requires name and in (query, header, cookie)
9. Validate http: requires scheme (basic, bearer)
10. Validate oauth2: requires flows object
11. Validate openIdConnect: requires openIdConnectUrl
12. Implement `updateSecurityScheme(spec: object, name: string, updates: Partial<SecuritySchemeObject>)`
13. Implement `deleteSecurityScheme(spec: object, name: string)`
14. Check if scheme is used before deleting
15. Implement `applyToEndpoint(spec: object, endpoint: {path, method}, schemeName: string, scopes: string[])`
16. Set operation.security array with scheme and scopes
17. Implement `applyGlobal(spec: object, schemeName: string, scopes: string[])`
18. Set top-level spec.security array
19. Add JSDoc: "The API bouncer - checking IDs, managing the VIP list, and keeping the riffraff out"
20. **Jest tests** `tests/unit/tools/security-configure-tool.test.ts`:

- Test addSecurityScheme for apiKey type
- Test addSecurityScheme for http bearer type
- Test addSecurityScheme for oauth2 with flows
- Test validateSecurityScheme detects invalid schemes
- Test updateSecurityScheme merges changes
- Test deleteSecurityScheme checks usage
- Test applyToEndpoint sets operation.security
- Test applyToEndpoint handles scopes correctly
- Test applyGlobal sets top-level security
- Test validate() requires scheme_name
- Test validate() requires scheme_definition for add_scheme

---

## Part 18: Tool #10 - spec_version (Version Control Tool)

1. Create `src/tools/spec-version-tool.ts` extending BaseTool
2. Define Zod schema: action (create_version, list_versions, get_version, compare_versions, rollback, diff), version_name, description, compare_from, compare_to, diff_format
3. Implement `createVersionAction(params)` calling version-manager.createVersion()
4. Suggest semver based on changes (breaking = major, additive = minor, docs = patch)
5. Implement `listVersionsAction()` returning version array with metadata summary
6. Implement `getVersionAction(version: string)` loading version spec and full metadata
7. Implement `compareVersionsAction(from: string, to: string)` using diff-calculator
8. Format comparison results for LLM readability
9. Implement `rollbackAction(version: string)` calling version-manager.rollbackToVersion()
10. Add safety confirmation message in response
11. Implement `diffAction(from: string, to: string, format: string)`
12. Generate diff in JSON, markdown, or HTML format
13. Add JSDoc: "The time machine - because sometimes you need to undo that 3am coding session"
14. **Jest tests** `tests/unit/tools/spec-version-tool.test.ts`:

- Mock version-manager, diff-calculator
- Test createVersionAction creates version
- Test createVersionAction validates version name
- Test listVersionsAction returns sorted versions
- Test getVersionAction loads version data
- Test compareVersionsAction calls diff-calculator
- Test compareVersionsAction formats results
- Test rollbackAction calls version-manager
- Test rollbackAction includes safety warning
- Test diffAction generates correct format
- Test validate() requires version_name for create_version
- Test validate() requires compare_from and compare_to for compare

---

## Part 19: Breaking Change Detection & oasdiff Integration

1. Install oasdiff: `npm install -g oasdiff` or use npx
2. Create `src/services/breaking-change-detector.ts`
3. Implement `detectBreakingChanges(oldSpecPath: string, newSpecPath: string): Promise<BreakingChangesResult>`
4. Execute oasdiff via child_process: `oasdiff breaking old.yaml new.yaml --format json`
5. Parse oasdiff JSON output
6. Implement `categorizeBreakingChanges(changes: OasdiffChange[]): CategorizedChanges`
7. Group by type: endpoint_removed, parameter_added_required, response_changed, etc.
8. Implement `formatBreakingChangesReport(changes: CategorizedChanges): string`
9. Create human-readable markdown report
10. **Jest tests** `tests/unit/services/breaking-change-detector.test.ts`:

- Mock child_process.exec
- Test detectBreakingChanges executes oasdiff
- Test parseOasdiffOutput handles JSON correctly
- Test categorizeBreakingChanges groups by type
- Test formatBreakingChangesReport creates markdown
- Test handles no breaking changes case
- Test handles oasdiff execution error

11. Enhance spec_validate tool to accept compare_against parameter
12. When compare_against provided, call breaking-change-detector
13. Include breaking changes in validation report
14. Update version-manager to run breaking change detection on createVersion
15. Store breaking changes in version metadata

---

## Part 20: MCP Testing Infrastructure & Helpers

1. Create `tests/helpers/mcp-test-client.ts`: Mock MCP client for JSON-RPC tool calls
2. Implement `McpTestClient` class with connection management
3. Implement `callTool(toolName: string, params: object): Promise<ToolResult>`
4. Format JSON-RPC 2.0 request: `{ jsonrpc: '2.0', id: 1, method: 'tools/call', params }`
5. Send via HTTP POST to /mcp endpoint
6. Parse JSON-RPC response
7. Implement `assertToolSuccess(result: ToolResult, expectedContent?: string)`
8. Check isError === false
9. Check content array exists
10. Optionally match content text
11. Implement `assertToolError(result: ToolResult, expectedError?: string)`
12. Check isError === true
13. Match error message
14. Create `tests/helpers/test-server.ts`: Start/stop server for integration tests
15. Implement `startTestServer(config?: Partial<Config>): Promise<{server, url, cleanup}>`
16. Create temporary data directory
17. Initialize test server with test config
18. Return cleanup function
19. Implement `stopTestServer(server: FastifyInstance)` with graceful shutdown
20. Create `tests/helpers/fixture-manager.ts`: Manage test fixtures
21. Implement `createTestApi(apiId: string, spec: object)` writing to test data dir
22. Implement `loadFixture(name: string): object` loading from tests/fixtures/
23. Implement `cleanupTestData()` removing test directories
24. **Jest tests** `tests/unit/helpers/mcp-test-client.test.ts`:

- Test callTool formats JSON-RPC correctly
- Test assertToolSuccess passes on success
- Test assertToolError passes on error

25. Document usage in `docs/TESTING.md`

---

## Part 21: Comprehensive Integration Test Suite

1. Create `tests/integration/full-workflow.test.ts`: End-to-end workflow test
2. Test scenario: Create API from scratch with all operations
3. Start test server
4. Create API with initial spec
5. Call metadata_update to set info
6. Call schema_manage to add User schema
7. Call endpoint_manage to add POST /users
8. Call parameters_configure to add request body
9. Call responses_configure to add 201 response
10. Call security_configure to add bearer auth
11. Call spec_version to create v1.0.0
12. Call spec_validate to verify validity
13. Verify all changes persisted
14. Check audit log entries
15. Clean up test data
16. Create `tests/integration/version-workflow.test.ts`: Version control workflow
17. Create API with initial version
18. Make changes
19. Create new version
20. Compare versions
21. Rollback to previous
22. Verify rollback successful
23. Create `tests/integration/reference-workflow.test.ts`: $ref management
24. Create schema
25. Add endpoint with inline response schema
26. Convert to $ref with references_manage
27. Verify $ref created
28. Validate all references
29. Create `tests/integration/validation-workflow.test.ts`: Validation scenarios
30. Test valid spec passes
31. Test invalid spec fails with errors
32. Test breaking change detection
33. Run all integration tests: `npm run test:integration`

---

## Part 22: Documentation - ARCHITECTURE.md

1. Create `docs/ARCHITECTURE.md` with comprehensive architecture documentation
2. **Section: Overview** - high-level system description, goals, design principles
3. **Section: Technology Stack** - list all dependencies with versions and rationale
4. **Section: Folder Structure** - document every folder and its purpose
5. **Section: Design Patterns** - explain BaseTool pattern, service layer, storage abstraction
6. **Section: Data Flow** - diagram showing MCP request → tool → service → storage → response
7. **Section: File Storage Architecture** - explain folder structure, metadata schema, versioning approach
8. **Section: Concurrency & Locking** - document file locking strategy, atomic operations
9. **Section: Error Handling** - explain error hierarchy, error responses, logging
10. **Section: Testing Strategy** - unit vs integration vs manual testing approach
11. **Section: OpenAPI Version Support** - explain handling of Swagger 2.0, OpenAPI 3.0, 3.1
12. **Section: Extension Points** - how to add new tools, services, validators
13. Include code examples for each pattern
14. Include diagrams (ASCII or mermaid)
15. Add links to relevant source files

---

## Part 23: Documentation - TOOLS.md, API.md, TESTING.md

1. Create `docs/TOOLS.md`: Complete MCP tools reference
2. For each of 10 tools, document:

- Purpose and use cases
- Parameter schema with descriptions
- Example usage with LLM prompts
- Return value structure
- Error cases and handling
- Related tools

3. Add workflow examples: "How to create authenticated endpoint", "How to version API", "How to refactor with $refs"
4. Create `docs/API.md`: REST API documentation
5. Document GET /health endpoint: request, response, status codes
6. Document POST /mcp endpoint: MCP protocol, JSON-RPC format
7. Document authentication (once implemented)
8. Document rate limiting (once implemented)
9. Create `docs/TESTING.md`: Testing guide
10. Explain testing philosophy and coverage goals
11. Document how to run tests: `npm test`, `npm run test:watch`, `npm run test:coverage`
12. Document how to debug tests: `npm run test:debug`, using VS Code debugger
13. Explain test helpers: mcp-test-client, test-server, fixture-manager
14. Document how to add new tests for new tools
15. Include troubleshooting section

---

## Part 24: Documentation - AGENTS.md & CONTRIBUTING.md

1. Create `AGENTS.md` following https://agents.md specification
2. **Section: Setup commands** - installation: `npm install`, dev: `npm run dev`, test: `npm test`
3. **Section: Dev environment tips** - how to use test:watch, how to debug, folder navigation
4. **Section: Testing instructions** - run tests before commit, add tests for new code, coverage threshold 80%
5. **Section: Code style** - camelCase vars, PascalCase classes, Uncle Bob principles, JSDoc required
6. **Section: Tool implementation** - how to add new MCP tool extending BaseTool
7. **Section: PR instructions** - title format, branch naming, test requirements, lint requirements
8. **Section: Architecture notes** - link to ARCHITECTURE.md, explain BaseTool pattern
9. **Section: Common tasks** - how to add tool, how to add service, how to add tests
10. Create `.github/CONTRIBUTING.md`: Contribution guidelines
11. Welcome message and project goals
12. How to report bugs and request features
13. How to submit PRs: fork, branch, code, test, lint, PR
14. Code review process
15. Style guide: reference ESLint config, Prettier, TypeScript strict mode
16. Testing requirements: all new code needs tests
17. Documentation requirements: update docs/ for new features
18. License information

---

## Part 25: Docker with Debian, Node.js, and PM2

1. Create `Dockerfile` with multi-stage build
2. **Builder stage**: Use node:20-bookworm as base
3. Install dependencies: `npm ci`
4. Build TypeScript: `npm run build`
5. **Production stage**: Use debian:bookworm-slim
6. Install Node.js 20 from NodeSource repository: `curl -fsSL https://deb.nodesource.com/setup_20.x | bash -`
7. Install PM2 globally: `npm install -g pm2`
8. Create app user: `useradd -m -s /bin/bash appuser`
9. Copy built application from builder: dist/, node_modules/, package.json
10. Create data directory: `mkdir -p /app/data && chown appuser:appuser /app/data`
11. Switch to appuser: `USER appuser`
12. Create `ecosystem.config.js` for PM2:

- App name: 'openapi-mcp-server'
- Script: 'dist/server.js'
- Instances: 'max' (use all CPU cores)
- Exec mode: 'cluster'
- Max memory restart: '500M'
- Error log: '/app/logs/error.log'
- Out log: '/app/logs/out.log'
- Env: PORT, DATA_DIR, LOG_LEVEL

13. Set CMD: `["pm2-runtime", "start", "ecosystem.config.js"]`
14. Add health check: `HEALTHCHECK --interval=30s --timeout=3s CMD curl -f http://localhost:3000/health || exit 1`
15. Create `.dockerignore`: node_modules, tests, coverage, .git, data, *.log, *.md (except README)
16. Create `docker-compose.yml` for local development:

- Service: openapi-mcp-server
- Build: current directory
- Ports: 3000:3000
- Volumes: ./data:/app/data (persist data)
- Environment: LOG_LEVEL=debug

17. Add npm scripts: `docker:build`, `docker:run`, `docker:stop`, `docker:logs`, `docker:exec`
18. Create `docs/DEPLOYMENT.md`: Docker deployment guide
19. Document build process: `docker build -t openapi-mcp-server .`
20. Document run process: `docker-compose up -d`
21. Document PM2 commands: `docker exec openapi-mcp-server pm2 list`, `pm2 logs`, `pm2 monit`
22. Document volume mounts for data persistence
23. Document environment variables
24. Test Docker build: `npm run docker:build`
25. Test Docker run: `npm run docker:run`, verify health check, test MCP endpoint

---

## Part 26: Examples, Polish, and Final Testing

1. Create `examples/` directory for usage examples
2. Create `examples/create-api.ts`: Script demonstrating API creation with all tools
3. Use mcp-test-client to call tools programmatically
4. Create Petstore API step by step
5. Create `examples/version-management.ts`: Version control workflow example
6. Create versions, compare, rollback
7. Create `examples/breaking-changes.ts`: Demonstrate breaking change detection
8. Make breaking changes, detect them, show report
9. Create `examples/curl-examples.md`: cURL commands for all MCP tools
10. Document JSON-RPC request format for each tool
11. Update `README.md` with comprehensive content:

- Project description and goals
- Features list (10 MCP tools, version control, validation, etc.)
- Quick start guide
- Architecture overview
- Links to detailed docs
- Contributing section
- License

12. Add badges: Build status (GitHub Actions), test coverage (Codecov), license
13. Create `CHANGELOG.md` with v1.0.0 entry
14. List all implemented features and tools
15. Run full linting: `npm run lint -- --fix`
16. Run full test suite: `npm run test:coverage`
17. Verify 80%+ coverage achieved
18. Run integration tests: verify all workflows pass
19. Manual end-to-end test:

- Start server: `npm run dev`
- Create API via MCP
- Add schemas, endpoints, parameters, responses, security
- Create versions
- Validate
- Verify all persisted in data/
- Check audit.jsonl

20. Final code review: check for console.logs, TODO comments, unused imports
21. Update all JSDoc to ensure humor and completeness
22. Create GitHub release: tag v1.0.0, add release notes
23. Optional: Publish to npm (if making public package)

---

## Success Criteria

✅ All 10 MCP tools implemented and tested individually
✅ 80%+ Jest test coverage (unit + integration)
✅ Zero ESLint errors or warnings
✅ All documentation complete (ARCHITECTURE, TOOLS, API, TESTING, AGENTS, CONTRIBUTING, DEPLOYMENT)
✅ Docker image builds and runs with PM2
✅ Complete integration test suite passes
✅ Manual end-to-end workflow successful
✅ Humorous JSDoc on every class and function
✅ BaseTool pattern consistently applied
✅ Version control with audit trail working

**Timeline:** 4-6 weeks with focus on quality and testing at each step

### To-dos

- [ ] Project scaffolding, folder structure, documentation setup, and tooling configuration
- [ ] Core infrastructure: BaseTool pattern, file storage, logging, error handling with tests
- [ ] Spec manager service and first working tool: spec_read with full testing
- [ ] Validation service with Spectral integration and spec_validate tool
- [ ] Version management infrastructure: version-manager, audit-logger, diff-calculator
- [ ] First write tool: metadata_update with write patterns and testing
- [ ] Schema management tool with CRUD operations and property-level editing
- [ ] Endpoint management tools: endpoint_manage, parameters_configure, responses_configure
- [ ] Complete responses tool and implement references_manage tool
- [ ] Security configuration tool with scheme and requirement management
- [ ] Version control tool tying together version management infrastructure
- [ ] Breaking change detection with oasdiff integration and changelog generation
- [ ] MCP server testing infrastructure and debugging setup
- [ ] Docker configuration with Debian, Node.js, and PM2 runtime
- [ ] Complete documentation, examples, and final polish